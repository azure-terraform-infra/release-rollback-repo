name: Release Workflow
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

      version:
        description: 'Release version (e.g. v1.2.3)'
        required: true
        type: string

      tag-release:
          description: "Tag the release in all repos"
          type: boolean
          default: true

      maintenance:
          description: "Enable maintenance mode during deployment"
          type: boolean
          default: true
      
      deploy-release:
          description: "Deploy the release after tagging"
          type: boolean
          default: true

      rollback:
        description: "Perform rollback instead of release"
        type: boolean
        default: false

env:
  VERSION: ${{ github.event.inputs.version }}
  REGISTRY: "ghcr.io/dolvladzio"
  ORG: "dolvladzio"
  REPOS: "app-1 app-2 app-3"
  PAT: ${{ secrets.PAT }}
  ENVIRONMENT: ${{ inputs.environment }}

jobs:
    create-release-tag:
      if: ${{ inputs.tag-release }}
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Login to registry
          run: |
            echo "${{ env.PAT }}" | \
              docker login ghcr.io -u ${{ github.actor }} --password-stdin

        - name: Create tags and releases in repos
          run: |
            for repo in ${{ env.REPOS}}; do
              echo "Processing $repo with version ${{ env.VERSION }}"

              # 1️⃣ Find default branch sha
              BRANCH=$(curl -s -H "Authorization: token ${{ env.PAT }}" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo" | jq -r .default_branch)
              SHA=$(curl -s -H "Authorization: token ${{ env.PAT }}" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo/git/refs/heads/$BRANCH" | jq -r .object.sha)

              # 2️⃣ Create tag (ignore if exists)
              curl -sS -X POST -H "Authorization: token ${{ env.PAT }}" \
                -d "{\"ref\":\"refs/tags/${{ env.VERSION }}\",\"sha\":\"${SHA}\"}" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo/git/refs" || echo "Tag exists or error"

              # 3️⃣ Create release (ignore if exists)
              curl -sS -X POST -H "Authorization: token ${{ env.PAT }}" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo/releases" \
                -d "{
                      \"tag_name\": \"${{ env.VERSION }}\",
                      \"name\": \"Release ${{ env.VERSION }}\",
                      \"body\": \"Automated release for version ${{ env.VERSION }}\",
                      \"draft\": false,
                      \"prerelease\": false
                    }" || echo "Release exists or error"
            done

        - name: Wait for all images to be available
          run: |
            sleep 30  # initial wait before checking
            echo "⏳Checking images"

            for i in ${{ env.REPOS}}; do
              IMAGE="${{ env.REGISTRY }}/$i:${{ env.VERSION }}"
              echo "Waiting for $IMAGE ..."

              # retry logic: 30 attempts x 5 sec = 150 sec max wait
              for attempt in {1..30}; do
                if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
                  echo "✅ Found $IMAGE"
                  break
                fi

                echo "Not yet available, retry $attempt/30..."
                sleep 5
              done

              # if not found after retries → fail
              if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
                echo "❌ $IMAGE NOT found after waiting"
                exit 1
              fi
            done

            echo "✅ All images are available!"

    # maintenance:
    #   if: ${{ inputs.maintenance }}
    #   name: Maintenance Mode
    #   runs-on: ubuntu-latest
    #   steps:
    #     - name: Checkout code
    #       uses: actions/checkout@v4

    deploy-release:
      if: ${{ inputs.deploy-release }}
      needs: create-release-tag
      name: Deploy Release
      runs-on: ubuntu-latest
      steps:
        - name: Trigger the Ansible runner
          uses: peter-evans/repository-dispatch@v3
          with:
            token: ${{ secrets.PAT }}
            repository: ${{ github.actor }}/app-charts
            event-type: charts-deployment-trigger
            client-payload: |
              {
                "environment": "${{ env.ENVIRONMENT }}",
                "version": "${{ env.VERSION }}"
              }

    rollback-release:
      if: ${{ inputs.rollback }}
      name: Rollback Release
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Helm install
          uses: azure/setup-helm@v3
          with:
            version: v3.11.2

        - name: Configure kubectl
          uses: azure/setup-kubectl@v3
          with:
            version: 'latest'

        - name: Rollback to ${{ env.VERSION }} version
          run: |
            for i in ${{ env.REPOS}}; do
              echo "Rolling back $i version ${{ env.VERSION }} to ${{ env.ENVIRONMENT }}"

                if helm upgrade --install app-$i ./charts-repo/app-$i \
                  --namespace ${{ env.ENVIRONMENT }} \
                  --set image.tag=${{ env.VERSION }} \
                  charts/$i ; then
                  echo "✅ Rolled back $i successfully"
                else
                  echo "❌ Roll back $i failed"
                  exit 1
                fi
            done