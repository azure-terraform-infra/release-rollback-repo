name: Release Workflow
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - prod

      version:
        description: 'Release version (e.g. v1.2.3)'
        required: true
        type: string

      tag-release:
          description: "Tag the release in all repos"
          type: boolean
          default: true

      maintenance:
          description: "Enable maintenance mode during deployment"
          type: boolean
          default: false
      
      deploy-release:
          description: "Deploy the release after tagging"
          type: boolean
          default: true

      rollback:
        description: "Perform rollback instead of release"
        type: boolean
        default: false

env:
  VERSION: ${{ github.event.inputs.version }}
  REGISTRY: "${{ inputs.environment }}containerregistry5th7aytwop.azurecr.io"
  ORG: ${{ github.repository_owner }}
  REPOS: "app-1 app-2 app-3"
  PAT: ${{ secrets.PAT }}
  ENVIRONMENT: ${{ inputs.environment }}

jobs:
    create-release-tag:
      if: ${{ inputs.tag-release }}
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Azure login
          uses: azure/login@v2
          with:
              creds: ${{ secrets.AZURE_CREDENTIALS }}

        - name: Log in to Azure Container Registry
          run: az acr login --name ${{ env.REGISTRY }}

        - name: Create tags and releases in repos
          run: |
            for repo in ${{ env.REPOS}}; do
              echo "Processing $repo with version ${{ env.VERSION }}"

              # 1️⃣ Find default branch sha
              BRANCH=$(curl -s -H "Authorization: token ${{ env.PAT }}" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo" | jq -r .default_branch)
              SHA=$(curl -s -H "Authorization: token ${{ env.PAT }}" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo/git/refs/heads/$BRANCH" | jq -r .object.sha)

              # 2️⃣ Create tag (ignore if exists)
              curl -sS -X POST -H "Authorization: token ${{ env.PAT }}" \
                -d "{\"ref\":\"refs/tags/${{ env.VERSION }}\",\"sha\":\"${SHA}\"}" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo/git/refs" || echo "Tag exists or error"

              # 3️⃣ Create release (ignore if exists)
              curl -sS -X POST -H "Authorization: token ${{ env.PAT }}" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/${{ env.ORG }}/$repo/releases" \
                -d "{
                      \"tag_name\": \"${{ env.VERSION }}\",
                      \"name\": \"Release ${{ env.VERSION }}\",
                      \"body\": \"Automated release for version ${{ env.VERSION }}\",
                      \"draft\": false,
                      \"prerelease\": false
                    }" || echo "Release exists or error"
            done

        - name: Wait for all images to be available
          run: |
            sleep 90  # initial wait before checking
            echo "⏳Checking images"

            for i in ${{ env.REPOS}}; do
              IMAGE="${{ env.REGISTRY }}/$i:${{ env.VERSION }}"
              echo "Waiting for $IMAGE ..."

              # retry logic: 30 attempts x 5 sec = 150 sec max wait
              for attempt in {1..30}; do
                if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
                  echo "✅ Found $IMAGE"
                  break
                fi

                echo "⏳Not yet available, retry $attempt/30..."
                sleep 5
              done

              # if not found after retries → fail
              if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
                echo "❌ $IMAGE NOT found after waiting"
                exit 1
              fi
            done

            echo "✅ All images are available!"

    # maintenance:
    #   if: ${{ inputs.maintenance }}
    #   name: Maintenance Mode
    #   runs-on: ubuntu-latest
    #   steps:
    #     - name: Checkout code
    #       uses: actions/checkout@v4

    deploy-release:
      if: ${{ inputs.deploy-release }}
      needs: create-release-tag
      name: Deploy Release
      runs-on: ubuntu-latest
      steps:
        - name: Trigger the App Charts runner
          uses: peter-evans/repository-dispatch@v3
          with:
            token: ${{ secrets.PAT }}
            repository: ${{ env.ORG }}/app-charts
            event-type: charts-deployment-trigger
            client-payload: |
              {
                "environment": "${{ env.ENVIRONMENT }}",
                "version": "${{ env.VERSION }}"
              }

        - name: Wait for workflow to complete
          env:
            GH_TOKEN: ${{ secrets.PAT }}
          run: |
            echo "⏳Waiting for Charts CI/CD Pipeline workflow to start..."
            sleep 60
            
            TIMEOUT=1800
            ELAPSED=0
            INTERVAL=15
            FOUND=false
            
            while [ $ELAPSED -lt $TIMEOUT ]; do
              # Get recent workflow runs
              RUNS=$(gh run list \
                --repo ${{ env.ORG }}/app-charts \
                --workflow "Charts CI/CD Pipeline" \
                --limit 5 \
                --json status,conclusion,createdAt,databaseId)
              
              # Find the most recent run created after this step started
              LATEST_RUN=$(echo "$RUNS" | jq -r '.[0]')
              
              if [ "$LATEST_RUN" != "null" ] && [ "$LATEST_RUN" != "" ]; then
                FOUND=true
                STATUS=$(echo "$LATEST_RUN" | jq -r '.status')
                CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.conclusion')
                RUN_ID=$(echo "$LATEST_RUN" | jq -r '.databaseId')
                
                echo "[${ELAPSED}s] Workflow run #$RUN_ID - Status: $STATUS, Conclusion: $CONCLUSION"
                
                if [ "$STATUS" == "completed" ]; then
                  if [ "$CONCLUSION" == "success" ]; then
                    echo "✅ Workflow completed successfully"
                    exit 0
                  else
                    echo "❌ Workflow failed with conclusion: $CONCLUSION"
                    exit 1
                  fi
                fi
              else
                echo "[${ELAPSED}s] Waiting for workflow to start..."
              fi
              
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
            
            if [ "$FOUND" == "false" ]; then
              echo "❌ No workflow run found"
            else
              echo "❌ Timeout waiting for workflow to complete"
            fi
            exit 1

    rollback-release:
      if: ${{ inputs.rollback }}
      name: Rollback Release
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Rollback to ${{ env.VERSION }} version
          uses: peter-evans/repository-dispatch@v3
          with:
            token: ${{ secrets.PAT }}
            repository: ${{ env.ORG }}/app-charts
            event-type: charts-deployment-trigger
            client-payload: |
              {
                "environment": "${{ env.ENVIRONMENT }}",
                "version": "${{ env.VERSION }}"
              }

        - name: Wait for workflow to complete
          env:
            GH_TOKEN: ${{ secrets.PAT }}
          run: |
            echo "⏳ Waiting for Charts CI/CD Pipeline workflow to start..."
            sleep 15
            
            TIMEOUT=1800
            ELAPSED=0
            INTERVAL=15
            FOUND=false
            
            while [ $ELAPSED -lt $TIMEOUT ]; do
              # Get recent workflow runs
              RUNS=$(gh run list \
                --repo ${{ env.ORG }}/app-charts \
                --workflow "Charts CI/CD Pipeline" \
                --limit 5 \
                --json status,conclusion,createdAt,databaseId)
              
              # Find the most recent run
              LATEST_RUN=$(echo "$RUNS" | jq -r '.[0]')
              
              if [ "$LATEST_RUN" != "null" ] && [ "$LATEST_RUN" != "" ]; then
                FOUND=true
                STATUS=$(echo "$LATEST_RUN" | jq -r '.status')
                CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.conclusion')
                RUN_ID=$(echo "$LATEST_RUN" | jq -r '.databaseId')
                
                echo "[${ELAPSED}s] Workflow run #$RUN_ID - Status: $STATUS, Conclusion: $CONCLUSION"
                
                if [ "$STATUS" == "completed" ]; then
                  if [ "$CONCLUSION" == "success" ]; then
                    echo "✅ Workflow completed successfully"
                    exit 0
                  else
                    echo "❌ Workflow failed with conclusion: $CONCLUSION"
                    exit 1
                  fi
                fi
              else
                echo "[${ELAPSED}s] Waiting for workflow to start..."
              fi
              
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
            
            if [ "$FOUND" == "false" ]; then
              echo "❌ No workflow run found"
            else
              echo "❌ Timeout waiting for workflow to complete"
            fi
            exit 1